import { AIClientFactory } from '../clients/AIClientFactory';
import { ChatMessage } from '../clients/AIClient';
import { ProductServiceClient } from '../clients/ProductServiceClient';
import * as fs from 'fs';
import * as path from 'path';

// Type definitions for API responses
interface QwenAnalysisResponse {
  choices: Array<{
    message: {
      content: string;
    };
  }>;
}

interface QwenImageGenResponse {
  output: {
    choices: Array<{
      message: {
        content: Array<{
          image: string;
        }>;
      };
    }>;
  };
}

export interface ImageUploadResponse {
  success: boolean;
  imageUrl: string;
  message?: string;
}

export interface DetectedFurnitureItem {
  itemId: string;
  furnitureType: string;
  boundingBox: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  confidence: number;
}

export interface FurnitureDetectionResponse {
  success: boolean;
  detectedItems: DetectedFurnitureItem[];
  isEmpty: boolean;
  estimatedRoomDimensions?: {
    length: number;
    width: number;
    height: number;
    unit: string;
  };
}

export interface FurnitureReplacementResponse {
  success: boolean;
  processedImageUrl: string;
  replacement: {
    detectedItemId: string;
    replacementProductId: string;
    replacementProductName: string;
    appliedAt: string;
  };
}

export interface FurniturePlacementResponse {
  success: boolean;
  processedImageUrl: string;
  placement: {
    placementId: string;
    productId: string;
    productName: string;
    imagePosition: { x: number; y: number };
    scale: number;
    rotation: number;
    appliedAt: string;
  };
}

export class ImageProcessingService {
  private uploadsDir: string;

  constructor(private productClient: ProductServiceClient) {
    // Create uploads directory if it doesn't exist
    this.uploadsDir = path.join(process.cwd(), 'uploads');
    if (!fs.existsSync(this.uploadsDir)) {
      fs.mkdirSync(this.uploadsDir, { recursive: true });
    }
  }

  /**
   * Helper function to create a clean URL with new query parameters
   * Always starts from the base URL without existing query parameters
   */
  private createProcessedImageUrl(baseUrl: string, params: Record<string, string | number>): string {
    try {
      // Parse the URL and remove existing query parameters
      const url = new URL(baseUrl);
      url.search = ''; // Clear all existing query parameters
      
      // Add new parameters
      Object.entries(params).forEach(([key, value]) => {
        url.searchParams.set(key, String(value));
      });
      return url.toString();
    } catch (error) {
      // If URL parsing fails, extract base URL manually
      const baseUrlClean = baseUrl.split('?')[0]; // Remove query parameters
      const queryString = Object.entries(params)
        .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`)
        .join('&');
      return `${baseUrlClean}?${queryString}`;
    }
  }

  /**
   * Helper function to safely append query parameters to a URL (legacy method)
   * Handles URLs that may already have query parameters or special characters
   */
  private appendQueryParams(baseUrl: string, params: Record<string, string | number>): string {
    // Use the new clean method instead
    return this.createProcessedImageUrl(baseUrl, params);
  }

  /**
   * Upload and process image
   */
  async uploadImage(imageBuffer: Buffer, filename: string): Promise<ImageUploadResponse> {
    try {
      // Generate unique filename to avoid conflicts
      const timestamp = Date.now();
      const ext = path.extname(filename);
      const baseName = path.basename(filename, ext);
      const uniqueFilename = `${timestamp}-${baseName}${ext}`;
      
      // Save file to local uploads directory
      const filePath = path.join(this.uploadsDir, uniqueFilename);
      fs.writeFileSync(filePath, imageBuffer);
      
      // Return local server URL
      const baseUrl = process.env.BASE_URL || 'http://localhost:3001';
      const imageUrl = `${baseUrl}/uploads/${uniqueFilename}`;
      
      console.log(`Image uploaded: ${filename} -> ${imageUrl}`);
      
      return {
        success: true,
        imageUrl,
        message: 'Image uploaded successfully'
      };
    } catch (error) {
      console.error('Image upload error:', error);
      return {
        success: false,
        imageUrl: '',
        message: 'Failed to upload image'
      };
    }
  }

  /**
   * Detect furniture in image using Qwen-VL
   */
  async detectFurniture(
    imageUrl: string,
    roomDimensions: { length: number; width: number; height: number; unit: string }
  ): Promise<FurnitureDetectionResponse> {
    console.log(`Detecting furniture in image: ${imageUrl}`);

    try {
      const aiClient = AIClientFactory.getAvailableClient();
      
      if (aiClient) {
        return await this.detectFurnitureWithAI(imageUrl, roomDimensions, aiClient);
      } else {
        // Fallback to mock detection
        return this.generateMockDetection(imageUrl);
      }
    } catch (error) {
      console.error('Furniture detection error, falling back to mock:', error);
      return this.generateMockDetection(imageUrl);
    }
  }

  /**
   * Replace furniture using AI
   */
  async replaceFurniture(
    imageUrl: string,
    detectedItemId: string,
    replacementProductId: string
  ): Promise<FurnitureReplacementResponse> {
    console.log(`Replacing furniture: ${detectedItemId} with ${replacementProductId}`);

    try {
      // Get product details
      const products = await this.productClient.searchProducts({ 
        productIds: [replacementProductId] 
      });
      const product = products.find(p => p.id === replacementProductId);
      
      if (!product) {
        throw new Error('Product not found');
      }

      const aiClient = AIClientFactory.getAvailableClient();
      
      if (aiClient) {
        return await this.replaceFurnitureWithAI(imageUrl, detectedItemId, product, aiClient);
      } else {
        // Fallback to mock replacement
        return this.generateMockReplacement(imageUrl, detectedItemId, product);
      }
    } catch (error) {
      console.error('Furniture replacement error, falling back to mock:', error);
      // Generate mock response
      const products = await this.productClient.searchProducts({ 
        productIds: [replacementProductId] 
      });
      const product = products.find(p => p.id === replacementProductId);
      
      return this.generateMockReplacement(imageUrl, detectedItemId, product || {
        id: replacementProductId,
        name: 'Unknown Product',
        price: 0,
        currency: 'USD'
      } as any);
    }
  }

  /**
   * Place furniture in empty room using AI
   */
  async placeFurniture(
    imageUrl: string,
    productId: string,
    imagePosition: { x: number; y: number },
    rotation: number,
    scale: number
  ): Promise<FurniturePlacementResponse> {
    console.log(`Placing furniture: ${productId} at position (${imagePosition.x}, ${imagePosition.y})`);

    try {
      // Get product details
      const products = await this.productClient.searchProducts({ 
        productIds: [productId] 
      });
      const product = products.find(p => p.id === productId);
      
      if (!product) {
        throw new Error('Product not found');
      }

      const aiClient = AIClientFactory.getAvailableClient();
      
      if (aiClient) {
        return await this.placeFurnitureWithAI(imageUrl, product, imagePosition, rotation, scale, aiClient);
      } else {
        // Fallback to mock placement
        return this.generateMockPlacement(imageUrl, product, imagePosition, rotation, scale);
      }
    } catch (error) {
      console.error('Furniture placement error, falling back to mock:', error);
      // Generate mock response
      const products = await this.productClient.searchProducts({ 
        productIds: [productId] 
      });
      const product = products.find(p => p.id === productId);
      
      return this.generateMockPlacement(imageUrl, product || {
        id: productId,
        name: 'Unknown Product',
        price: 0,
        currency: 'USD'
      } as any, imagePosition, rotation, scale);
    }
  }

  /**
   * Detect furniture using AI (Qwen-VL)
   */
  private async detectFurnitureWithAI(
    imageUrl: string,
    roomDimensions: any,
    aiClient: any
  ): Promise<FurnitureDetectionResponse> {
    const systemPrompt = `你是一个专业的室内设计师和家具识别专家。请分析这张房间图片，识别其中的家具并判断房间是否为空。

请按照以下JSON格式返回结果：
{
  "isEmpty": boolean,
  "detectedItems": [
    {
      "itemId": "unique_id",
      "furnitureType": "家具类型（如：沙发、桌子、椅子等）",
      "boundingBox": {
        "x": 边界框左上角x坐标（0-100百分比）,
        "y": 边界框左上角y坐标（0-100百分比）,
        "width": 边界框宽度（0-100百分比）,
        "height": 边界框高度（0-100百分比）
      },
      "confidence": 置信度（0-1之间的小数）
    }
  ],
  "estimatedRoomDimensions": {
    "length": 估计的房间长度,
    "width": 估计的房间宽度,
    "height": 估计的房间高度,
    "unit": "meters"
  }
}

如果房间是空的，isEmpty设为true，detectedItems为空数组。
如果房间有家具，isEmpty设为false，列出所有检测到的家具。`;

    const messages: ChatMessage[] = [
      { role: 'system', content: systemPrompt },
      { 
        role: 'user', 
        content: [
          {
            type: 'image_url',
            image_url: { url: imageUrl }
          },
          {
            type: 'text',
            text: `请分析这张房间图片，识别其中的家具。房间尺寸参考：${roomDimensions.length}x${roomDimensions.width}x${roomDimensions.height} ${roomDimensions.unit}`
          }
        ]
      }
    ];

    const response = await aiClient.chatCompletion({
      model: 'qwen3-vl-plus', // 使用Qwen-VL模型
      messages,
      temperature: 0.3,
      max_tokens: 1000,
    });

    const aiResponse = response.choices[0]?.message?.content || '';
    
    // Parse AI response
    try {
      const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const result = JSON.parse(jsonMatch[0]);
        return {
          success: true,
          detectedItems: result.detectedItems || [],
          isEmpty: result.isEmpty || false,
          estimatedRoomDimensions: result.estimatedRoomDimensions
        };
      }
    } catch (parseError) {
      console.error('Failed to parse AI detection response:', parseError);
    }

    // Fallback to mock if parsing fails
    return this.generateMockDetection(imageUrl);
  }

  /**
   * Replace furniture using AI
   */
  private async replaceFurnitureWithAI(
    imageUrl: string,
    detectedItemId: string,
    product: any,
    aiClient: any
  ): Promise<FurnitureReplacementResponse> {
    try {
      // Convert image URL to base64 for Qwen API
      let imageData: string;
      
      if (imageUrl.startsWith('http://localhost') || imageUrl.startsWith('http://127.0.0.1')) {
        // For local URLs, read the file directly
        const imagePath = imageUrl.replace(/^https?:\/\/[^\/]+/, '');
        const fullPath = path.join(process.cwd(), imagePath.replace('/uploads/', 'uploads/'));
        
        if (fs.existsSync(fullPath)) {
          const imageBuffer = fs.readFileSync(fullPath);
          const base64Image = imageBuffer.toString('base64');
          const mimeType = imagePath.endsWith('.png') ? 'image/png' : 'image/jpeg';
          imageData = `data:${mimeType};base64,${base64Image}`;
        } else {
          throw new Error('Local image file not found');
        }
      } else {
        // For remote URLs, use the URL directly
        imageData = imageUrl;
      }

      // Step 1: Use Qwen-VL to analyze the room and product
      console.log('Step 1: Analyzing room and product with Qwen-VL...');
      const systemPrompt = `你是一个专业的室内设计师。请帮助用户在房间图片中替换现有家具为Castlery家具产品。

请分析房间图片，然后生成一个详细的描述，说明如何将${product.name}替换到房间中，包括：
1. 房间的布局和风格
2. 产品的特点和风格
3. 最佳的放置位置和角度
4. 整体设计效果

请用中文描述，描述要详细且专业，适合用于图像生成。`;

      const analysisResponse = await fetch('https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.DASHSCOPE_API_KEY}`,
        },
        body: JSON.stringify({
          model: 'qwen3-vl-plus',
          messages: [
            {
              role: 'system',
              content: systemPrompt
            },
            {
              role: 'user',
              content: [
                {
                  type: 'image_url',
                  image_url: { url: imageData }
                },
                {
                  type: 'text',
                  text: `请分析这张房间图片，并描述如何将${product.name}替换到房间中，使其看起来自然和谐。`
                }
              ]
            }
          ],
          temperature: 0.7,
          max_tokens: 1000
        }),
      });

      if (!analysisResponse.ok) {
        const errorText = await analysisResponse.text();
        throw new Error(`Qwen-VL API error: ${analysisResponse.status} - ${errorText}`);
      }

      const analysisResult = await analysisResponse.json();
      const designDescription = analysisResult.choices[0].message.content;
      console.log('Analysis result:', designDescription);

      // Step 2: Use Qwen-Image to generate the rendered image
      console.log('Step 2: Generating rendered image with Qwen-Image...');
      const imagePrompt = `专业的室内设计渲染图，${designDescription}。高质量、真实感、专业摄影风格，自然光线，细节丰富。`;

      const imageGenResponse = await fetch('https://dashscope.aliyuncs.com/api/v1/services/aigc/multimodal-generation/generation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.DASHSCOPE_API_KEY}`,
        },
        body: JSON.stringify({
          model: 'qwen-image-max',
          input: {
            messages: [
              {
                role: 'user',
                content: [
                  {
                    text: imagePrompt
                  }
                ]
              }
            ]
          },
          parameters: {
            size: '1664*928',
            n: 1,
            prompt_extend: true,
            watermark: false
          }
        }),
      });

      if (!imageGenResponse.ok) {
        const errorText = await imageGenResponse.text();
        throw new Error(`Qwen-Image API error: ${imageGenResponse.status} - ${errorText}`);
      }

      const imageGenResult = await imageGenResponse.json();
      console.log('Qwen image generation result:', imageGenResult);

      // Extract generated image URL
      if (imageGenResult.output && imageGenResult.output.choices && imageGenResult.output.choices.length > 0) {
        const content = imageGenResult.output.choices[0].message.content;
        if (content && content.length > 0 && content[0].image) {
          const generatedImageUrl = content[0].image;
          
          // Download and save the generated image locally
          const imageResponse = await fetch(generatedImageUrl);
          if (!imageResponse.ok) {
            throw new Error(`Failed to download generated image: ${imageResponse.status}`);
          }
          const imageBuffer = await imageResponse.arrayBuffer();
          
          const timestamp = Date.now();
          const filename = `replaced_${timestamp}_${product.id}.png`;
          const localPath = path.join(this.uploadsDir, filename);
          
          fs.writeFileSync(localPath, Buffer.from(imageBuffer));
          
          const baseUrl = process.env.BASE_URL || 'http://localhost:3001';
          const processedImageUrl = `${baseUrl}/uploads/${filename}`;

          console.log(`Successfully generated replacement image: ${filename}`);

          return {
            success: true,
            processedImageUrl,
            replacement: {
              detectedItemId,
              replacementProductId: product.id,
              replacementProductName: product.name,
              appliedAt: new Date().toISOString(),
            }
          };
        } else {
          throw new Error('No generated image in response content');
        }
      } else {
        throw new Error('Invalid response format from Qwen-Image API');
      }

    } catch (error) {
      console.error('AI image generation failed:', error);
      
      // Fallback to copying original image with new filename
      console.log('Falling back to image copy approach...');
      try {
        let sourceImageBuffer: Buffer;
        
        if (imageUrl.startsWith('http://localhost') || imageUrl.startsWith('http://127.0.0.1')) {
          const imagePath = imageUrl.replace(/^https?:\/\/[^\/]+/, '');
          const fullPath = path.join(process.cwd(), imagePath.replace('/uploads/', 'uploads/'));
          
          if (fs.existsSync(fullPath)) {
            sourceImageBuffer = fs.readFileSync(fullPath);
          } else {
            throw new Error('Local image file not found');
          }
        } else {
          const imageResponse = await fetch(imageUrl);
          sourceImageBuffer = Buffer.from(await imageResponse.arrayBuffer());
        }
        
        const timestamp = Date.now();
        const filename = `replaced_${timestamp}_${product.id}.jpg`;
        const localPath = path.join(this.uploadsDir, filename);
        
        fs.writeFileSync(localPath, sourceImageBuffer);
        
        const baseUrl = process.env.BASE_URL || 'http://localhost:3001';
        const processedImageUrl = `${baseUrl}/uploads/${filename}`;

        console.log(`Created fallback replacement image: ${filename}`);

        return {
          success: true,
          processedImageUrl,
          replacement: {
            detectedItemId,
            replacementProductId: product.id,
            replacementProductName: product.name,
            appliedAt: new Date().toISOString(),
          }
        };
      } catch (fallbackError) {
        console.error('Fallback image copy also failed:', fallbackError);
        
        // Final fallback to query parameter approach
        const processedImageUrl = this.createProcessedImageUrl(imageUrl, {
          replaced: detectedItemId,
          with: product.id,
          fallback: 'true',
          t: Date.now()
        });

        return {
          success: true,
          processedImageUrl,
          replacement: {
            detectedItemId,
            replacementProductId: product.id,
            replacementProductName: product.name,
            appliedAt: new Date().toISOString(),
          }
        };
      }
    }
  }

  /**
   * Place furniture using AI
   */
  private async placeFurnitureWithAI(
    imageUrl: string,
    product: any,
    imagePosition: { x: number; y: number },
    rotation: number,
    scale: number,
    aiClient: any
  ): Promise<FurniturePlacementResponse> {
    try {
      // Convert image URL to base64 for Qwen API
      let imageData: string;
      
      if (imageUrl.startsWith('http://localhost') || imageUrl.startsWith('http://127.0.0.1')) {
        // For local URLs, read the file directly
        const imagePath = imageUrl.replace(/^https?:\/\/[^\/]+/, '');
        const fullPath = path.join(process.cwd(), imagePath.replace('/uploads/', 'uploads/'));
        
        if (fs.existsSync(fullPath)) {
          const imageBuffer = fs.readFileSync(fullPath);
          const base64Image = imageBuffer.toString('base64');
          const mimeType = imagePath.endsWith('.png') ? 'image/png' : 'image/jpeg';
          imageData = `data:${mimeType};base64,${base64Image}`;
        } else {
          throw new Error('Local image file not found');
        }
      } else {
        // For remote URLs, use the URL directly
        imageData = imageUrl;
      }

      // Step 1: Use Qwen-VL to analyze the room and product
      console.log('Step 1: Analyzing room for furniture placement with Qwen-VL...');
      const systemPrompt = `你是一个专业的室内设计师。请帮助用户在空房间图片中放置Castlery家具产品。

请分析房间图片，然后生成一个详细的描述，说明如何将${product.name}放置在房间中，包括：
1. 房间的布局和风格
2. 产品的特点和风格
3. 最佳的放置位置和角度（考虑用户指定的位置：x=${imagePosition.x}%, y=${imagePosition.y}%）
4. 整体设计效果

请用中文描述，描述要详细且专业，适合用于图像生成。`;

      const analysisResponse = await fetch('https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.DASHSCOPE_API_KEY}`,
        },
        body: JSON.stringify({
          model: 'qwen3-vl-plus',
          messages: [
            {
              role: 'system',
              content: systemPrompt
            },
            {
              role: 'user',
              content: [
                {
                  type: 'image_url',
                  image_url: { url: imageData }
                },
                {
                  type: 'text',
                  text: `请分析这张房间图片，并描述如何将${product.name}放置在房间中的指定位置（x=${imagePosition.x}%, y=${imagePosition.y}%），旋转角度${rotation}度，缩放比例${scale}，使其看起来自然和谐。`
                }
              ]
            }
          ],
          temperature: 0.7,
          max_tokens: 1000
        }),
      });

      if (!analysisResponse.ok) {
        const errorText = await analysisResponse.text();
        throw new Error(`Qwen-VL API error: ${analysisResponse.status} - ${errorText}`);
      }

      const analysisResult = await analysisResponse.json();
      const designDescription = analysisResult.choices[0].message.content;
      console.log('Analysis result:', designDescription);

      // Step 2: Use Qwen-Image to generate the rendered image
      console.log('Step 2: Generating rendered image with Qwen-Image...');
      const imagePrompt = `专业的室内设计渲染图，${designDescription}。高质量、真实感、专业摄影风格，自然光线，细节丰富。`;

      const imageGenResponse = await fetch('https://dashscope.aliyuncs.com/api/v1/services/aigc/multimodal-generation/generation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.DASHSCOPE_API_KEY}`,
        },
        body: JSON.stringify({
          model: 'qwen-image-max',
          input: {
            messages: [
              {
                role: 'user',
                content: [
                  {
                    text: imagePrompt
                  }
                ]
              }
            ]
          },
          parameters: {
            size: '1664*928',
            n: 1,
            prompt_extend: true,
            watermark: false
          }
        }),
      });

      if (!imageGenResponse.ok) {
        const errorText = await imageGenResponse.text();
        throw new Error(`Qwen-Image API error: ${imageGenResponse.status} - ${errorText}`);
      }

      const imageGenResult = await imageGenResponse.json();
      console.log('Qwen image generation result:', imageGenResult);

      // Extract generated image URL
      if (imageGenResult.output && imageGenResult.output.choices && imageGenResult.output.choices.length > 0) {
        const content = imageGenResult.output.choices[0].message.content;
        if (content && content.length > 0 && content[0].image) {
          const generatedImageUrl = content[0].image;
          
          // Download and save the generated image locally
          const imageResponse = await fetch(generatedImageUrl);
          if (!imageResponse.ok) {
            throw new Error(`Failed to download generated image: ${imageResponse.status}`);
          }
          const imageBuffer = await imageResponse.arrayBuffer();
          
          const timestamp = Date.now();
          const filename = `placed_${timestamp}_${product.id}.png`;
          const localPath = path.join(this.uploadsDir, filename);
          
          fs.writeFileSync(localPath, Buffer.from(imageBuffer));
          
          const baseUrl = process.env.BASE_URL || 'http://localhost:3001';
          const processedImageUrl = `${baseUrl}/uploads/${filename}`;

          console.log(`Successfully generated placement image: ${filename}`);

          return {
            success: true,
            processedImageUrl,
            placement: {
              placementId: `ai_placement_${timestamp}`,
              productId: product.id,
              productName: product.name,
              imagePosition,
              scale,
              rotation,
              appliedAt: new Date().toISOString(),
            }
          };
        } else {
          throw new Error('No generated image in response content');
        }
      } else {
        throw new Error('Invalid response format from Qwen-Image API');
      }

    } catch (error) {
      console.error('AI image generation failed:', error);
      
      // Fallback to copying original image with new filename
      console.log('Falling back to image copy approach...');
      try {
        let sourceImageBuffer: Buffer;
        
        if (imageUrl.startsWith('http://localhost') || imageUrl.startsWith('http://127.0.0.1')) {
          const imagePath = imageUrl.replace(/^https?:\/\/[^\/]+/, '');
          const fullPath = path.join(process.cwd(), imagePath.replace('/uploads/', 'uploads/'));
          
          if (fs.existsSync(fullPath)) {
            sourceImageBuffer = fs.readFileSync(fullPath);
          } else {
            throw new Error('Local image file not found');
          }
        } else {
          const imageResponse = await fetch(imageUrl);
          sourceImageBuffer = Buffer.from(await imageResponse.arrayBuffer());
        }
        
        const timestamp = Date.now();
        const filename = `placed_${timestamp}_${product.id}.jpg`;
        const localPath = path.join(this.uploadsDir, filename);
        
        fs.writeFileSync(localPath, sourceImageBuffer);
        
        const baseUrl = process.env.BASE_URL || 'http://localhost:3001';
        const processedImageUrl = `${baseUrl}/uploads/${filename}`;

        console.log(`Created fallback placement image: ${filename}`);

        return {
          success: true,
          processedImageUrl,
          placement: {
            placementId: `ai_placement_${timestamp}`,
            productId: product.id,
            productName: product.name,
            imagePosition,
            scale,
            rotation,
            appliedAt: new Date().toISOString(),
          }
        };
      } catch (fallbackError) {
        console.error('Fallback image copy also failed:', fallbackError);
        
        // Final fallback to query parameter approach
        const processedImageUrl = this.createProcessedImageUrl(imageUrl, {
          placed: product.id,
          pos: `${imagePosition.x},${imagePosition.y}`,
          rot: rotation,
          scale: scale,
          fallback: 'true',
          t: Date.now()
        });

        return {
          success: true,
          processedImageUrl,
          placement: {
            placementId: `placement_${Date.now()}`,
            productId: product.id,
            productName: product.name,
            imagePosition,
            scale,
            rotation,
            appliedAt: new Date().toISOString(),
          }
        };
      }
    }
  }

  /**
   * Generate mock furniture detection (fallback)
   */
  private generateMockDetection(imageUrl: string): FurnitureDetectionResponse {
    // Simulate detection based on URL or random
    const isEmpty = Math.random() > 0.5;
    
    if (isEmpty) {
      return {
        success: true,
        detectedItems: [],
        isEmpty: true,
        estimatedRoomDimensions: {
          length: 5,
          width: 4,
          height: 3,
          unit: 'meters'
        }
      };
    }

    // Generate mock detected furniture
    const mockItems: DetectedFurnitureItem[] = [
      {
        itemId: 'detected_1',
        furnitureType: 'sofa',
        boundingBox: { x: 20, y: 40, width: 40, height: 25 },
        confidence: 0.92
      },
      {
        itemId: 'detected_2',
        furnitureType: 'table',
        boundingBox: { x: 45, y: 65, width: 20, height: 15 },
        confidence: 0.87
      }
    ];

    return {
      success: true,
      detectedItems: mockItems,
      isEmpty: false,
      estimatedRoomDimensions: {
        length: 5,
        width: 4,
        height: 3,
        unit: 'meters'
      }
    };
  }

  /**
   * Generate mock furniture replacement (fallback)
   */
  private generateMockReplacement(
    imageUrl: string,
    detectedItemId: string,
    product: any
  ): FurnitureReplacementResponse {
    // For demo, return the original image URL with query parameters to simulate processing
    const processedImageUrl = this.appendQueryParams(imageUrl, {
      mock_replaced: detectedItemId,
      with: product.id,
      t: Date.now()
    });

    return {
      success: true,
      processedImageUrl,
      replacement: {
        detectedItemId,
        replacementProductId: product.id,
        replacementProductName: product.name,
        appliedAt: new Date().toISOString(),
      }
    };
  }

  /**
   * Generate mock furniture placement (fallback)
   */
  private generateMockPlacement(
    imageUrl: string,
    product: any,
    imagePosition: { x: number; y: number },
    rotation: number,
    scale: number
  ): FurniturePlacementResponse {
    // For demo, return the original image URL with query parameters to simulate processing
    const processedImageUrl = this.appendQueryParams(imageUrl, {
      mock_placed: product.id,
      pos: `${imagePosition.x},${imagePosition.y}`,
      t: Date.now()
    });

    return {
      success: true,
      processedImageUrl,
      placement: {
        placementId: `mock_placement_${Date.now()}`,
        productId: product.id,
        productName: product.name,
        imagePosition,
        scale,
        rotation,
        appliedAt: new Date().toISOString(),
      }
    };
  }
}